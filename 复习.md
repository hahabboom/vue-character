## 复习

### CSS模块

#### 1. 水平垂直居中

已知居中元素定宽高

1. position:absolute + 负margin

```
.out{
      position: relative;
      width: 500px;
      height: 500px;
}
.inner{
      width: 300px;
      height: 300px;
      position: absolute;
      top: 50%;
      left: 50%;
      margin-left: -150px;
      margin-top: -150px;
}
```

2. position:absolute + margin: auto

```
.out{
      position: relative;
      width: 500px;
      height: 500px;
}
.inner{
      width: 300px;
      height: 300px;
      position: absolute;
      margin: auto;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
}
```

3. position:absolute + calc

```
.out{
      position: relative;
      width: 500px;
      height: 500px;
}
.inner{
      width: 300px;
      height: 300px;
      position: absolute;
      top: calc(50% - 150px);
      left: calc(50% - 150px);
}
```

居中元素不定宽高

1. position:absolute + transform

```
.out{
      position: relative;
      width: 500px;
      height: 500px;
}
.inner{
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
}
```

2. flex （简单，省略）
3. css table属性

```
.out{
      width: 500px;
      height: 500px;
      display: table-cell;
      text-align: center;
      vertical-align: middle;
}
.inner{
      display: inline-block;
}
```

4. grid

```
.out{
      width: 500px;
      height: 500px;
      display: grid;
}
.inner{
      align-self: center;
      justify-self: center;
}
```



### JavaScript模块

#### 1. 实现一个new

```javascript
function my_new () {
    let obj = new Object()  // 新创建一个空对象
	let Fun = [].shift.call(arguments) // 获取构造函数
    obj.__proto__ = Fun.prototype  // 将obj连接到Fun的原型上
    let result = Fun.apply(obj, arguments) // 绑定this
    return typeof obj === 'object' ? result : obj // 确保返回的是一个对象
}
```

#### 2. 实现一个instanceof

```javascript
function my_instanceof(left, right) {
    let prototype = right.prototype // 获取类型的原型
    left = left.__proto__ // 获取对象的原型
    while (true) {   // 判断对象的类型是否等于类型的原型
        if (left === null)
            return false
        if (prototype === left)
            return true
        left = left.__proto__
	}
}
```

#### 3. 实现一个call

call是多个参数

```javascript
Function.prototype.my_call = function(context){
    let context = context || window // 不传入第一个参数，默认window
    context.fn = this // 添加一个属性（这里的this是call前面的函数，比如obj.sayhi.my_call(m) 这里m就是context， this就是sayhi）
    var args = [...arguments].slice(1) // 将context后面的参数取出来
    var result = context.fn(...args)
    delete context.fn // 删除fn
    return result
}
```

#### 4. 实现一个apply

apply 同理 ，B.apply(A, arguments); apply的参数是一个数组

```javascript
Function.prototype.my_apply = function (context) {
    var context = context || window
    context.fn = this
    var result
    // 需要判断是否存储第二个参数，如果存在就将第二个参数展开
    if(arguments[1]){
        result = context.fn(...arguments[1])
    } else {
        result = context.fn()
    }
    delete context.fn
    return result
}
```

#### 5. 实现bind

bind和apply，call的方法作用也是一致的，区别是bind会返回一个函数。并且我们可以通过bind实现柯里化

```javascript
Function.prototype.my_bind = function (context){
    console.log(this)
    if(typeof this !== 'function ') {
        throw new TypeError('error')
    }
    var self = this
    console.log(that)
    var args = Array.prototype.slice.call(arguments, 1);
    var fNOP = function () {};
    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }
    // 改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound
}
```

#### 6. 执行上下文，执行栈，作用域，闭包

执行上下文是评估和执行js代码的环境的抽象概念

有三种执行上下文类型：

1. 全局执行上下文：默认的上下文，任何不咋函数内部的代码都在全局上下文中。会执行两件事：常见一个全局的window对象，并且设置this的值等于这个全局对象，一个程序只会有一个全局执行上下文
2. 函数执行上下文：每当一个函数被调用时，都会为该函数创建一个新的上下文。每个函数都有他自己的执行上下文
3. eval执行代码：

**执行栈——用来存储代码运行时创建的所有执行上下文**

当js引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈，每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈顶。引擎会执行那些执行上下文位于栈顶的函数，当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的

闭包——保持对另一个作用域的引用

#### 7. 垃圾回收机制

##### 1. 新生代算法

在新生代空间中，内存空间分为两部分：分别为From空间和To空间，新分配的对象会被放入From空间中，当From空间被占满新生代GC就会被启动了。

算法会检查From空间中存活的对象并复制到To空间中，如果是不是存活对象的就会销毁，当复制完成之后将From空间和To空间角色互换，如此循环。

为什么不直接回收非存活对象，因为在To空间中是按顺序从头防止的，主要是防止直接收回未存活对象造成内存空间零散，导致无法存放内存稍微大一点的对象。防止内存碎片，但是劣势就是只能使用新生代内存的一半

##### 2. 老生代算法

什么情况下对象会出现在老生代空间中？1. 新生代对象是否已经经历过一次新生代算法，是就移到老生代空间 2. To空间的对象占比大小超过25%，在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间

老生代算法是：标记清除（会产生内存碎片）和标记压缩（整理内存碎片）

会遍历堆中所有对象，然后标记获得对象，在标记完成后，销毁所有没有被标记的对象。在标记大型内存时，可能需要几百毫秒才能完成一次标记。去处对象后悔造成对内存出现碎片的情况，当碎片超过一定限制后就会启动压缩算法，在压缩过程中，将活的对象向一段移动，直到所有对象都移动完成然后清理不需要的内存。

#### 8. JavaScript机制（Event Loop）

1. 单线程
2. JavaScript有个主线程和一个调用栈，所有任务都会放到调用栈中等待主线程来执行
3. 同步任务——主线程来执行的时候能立即执行的代码；异步任务——先去执行别的task，等我这里执行完毕再往task queue里面塞一个task的同步任务来等待被执行
4. 宏任务（由宿主-node，浏览器发起），微任务（js引擎发起）。因为在es3之前的版本，js本身没有发起异步请求的能力，es5之后js引入了promise，这样不需要浏览器，js本身也能够发起异步任务了
5. 宏任务（script，setTimeout，setInterval， I/O，setImmediate），微任务（Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver）
6. 任务队列（在每次迭代开始之后加入到队列中的任务需要**在下一次迭代开始之后才会被执行**），微任务队列（微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务）

event loop执行顺序：

1. 主线程自上而下执行代码所有代码
2. 如果是同步任务直接进去主线程被执行，二异步任务则进去event table并注册对应的回调函数
3. 异步任务完成后，event table会将这个函数一如event queue
4. 主线程任务执行完了之后，会从event queue中读取任务，进去到主线程去执行

#### 9. this

寻找 foo 的 this：

1. 首先判断函数类型

   若是箭头函数，this指向的是包裹箭头函数的第一个普通函数的this

   如果是使用了bind，call，apply，this指向的是第一个参数

   如果是普通函数进行下一步讨论

2. 通过分析普通函数如何被调用，如果是new的方式，this被固化在实例上，如果是不是new的方式进行下一步讨论

3. 分析是直接调用foo()还是obj.foo()方式，如果是foo() 则this为window，否则this为obj

#### 10. 深浅拷贝

浅拷贝：

1. Object.assign()

   ```javascript
   let b = Object.assign({}, a)
   ```

2. 扩展运算符 ...

   ```javascript
   let b = {...a}
   ```

深拷贝：

JSON.parse(JSON.stringify(object))

局限性：

1. 忽略undefined
2. 忽略symbol
3. 无法序列化函数
4. 不能解决循环引用的对象

#### 11. 原型

1. Object是所有对象的爸爸，所有对象都可以通过__ proto __找到它
2. Function是所有函数的爸爸，所有函数都可以通过__ proto __找到它
3. 函数的prototype是一个对象
4. 对象的__ proto __ 属性指向原型， __ proto __ 将对象和原型链接起来组成原型链

原型链就是通过__ proto __的方式链接起来

#### 12. == 和 ===

1. 首先判断两者类型是否相同，相同的话就是比较大小了
2. 类型不同就会进行类型转换
3. 先判断是否在对比null 和 undefined，是的话就返回 true
4. 会判断二者类型是否为 string 和 number ，是的话就会将字符串转换为number
5. 判断其中一方是否为boolean，是的话就会把 boolean 转换为number
6. 判断一方是否为Object且另一方为string、number或者symbol，是的话就会把object转为原型类型再判断

```javascript
[] == ![]

typeof []
> "object"
typeof ![]
> "boolean"
Number(![])
> 0
String([])
> ""
Number('')
> 0
0 == 0
```

#### 13. 闭包

闭包存在的意义就是可以间接访问函数内部的变量

#### 14. 继承

class只是语法糖，本质还是函数

##### 1. 组合继承

核心就是在子类的构造函数里面通过Parent.call(this)继承父类的属性，然后改变子类的原型为new Parent() 来继承父类的函数

```javascript
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

优点：构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数

缺点：在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费

##### 2. 寄生组合继承

对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，优化这一点

```javascript
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```



##### 3. class继承

核心在于使用extends表明继承自哪个父类，并且咋子类构造函数中必须调用super，因为这段代码可以看成Parent.call(this, value)

```javascript
class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}
class Child extends Parent {
  constructor(value) {
    super(value)
    this.val = value
  }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
```

#### 15. Proxy

能用来实现响应式

```javascript
  function reactive (target={}) {
    if (typeof target !== 'object' || target == null) {
      return target
    }
    const proxyConf = {
      get (target, key, receiver) {
        let result = Reflect.get(target, key, receiver)
        console.log('get', key)
        return result
      },
      set (target, key, val, receiver) {
        let result = Reflect.set(target, key, val, receiver)
        console.log('set', key, val)
        return result
      },
      deleteProperty (target, key) {
        let result = Reflect.defineProperty(target, key)
        console.log('delete', key)
        return result
      }
    }
    let observed = new Proxy(target, proxyConf)
    return observed
  }
```

#### 16. Generator

generator 最大的特点是可以控制函数的执行

```javascript
function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false}
console.log(it.next(13)) // => {value: 42, done: true}
```

generator函数可以用来解决回调函数

```javascript
function *fetch() {
    yield ajax(url, () => {})
    yield ajax(url1, () => {})
    yield ajax(url2, () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

#### 17. Promise

promise的构造函数时同步执行，promise.then函数时异步执行的

一旦从等待状态变成其他状态就永远不能更改状态了

在构建promise的时候，构造函数内部的代码是立即执行的

Promise实现了链式调用，也就是说每次调用then之后都返回一个promise，并且是一个全新的promise，原因也是因为状态不可变。如果在then中使用了return，那么return的值会被Promise.resolve()包装

Promise很好的解决了回调地狱的问题，但是也存在一些缺点，比如无法取消promise，错误需要通过回调函数捕获

#### 18. async和await

函数如果加上一个async ，该函数就会返回一个promise

```javascript
async function test() {
  return "1"
}
console.log(test()) // -> Promise {<resolved>: "1"}
```

async就是将函数返回值使用Promise.resolve()包裹了一下，和then中处理返回值一样，并且await只能配套async使用

aysnc和await可以说是异步终极解决方案了，相比直接使用Promise来说，优势在于处理then的调用链，能够更清晰准确写出代码，但是野村咋一些缺点，因为await将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了await会导致性能上的降低

```javascript
async function test() {
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch(url)
  await fetch(url1)
  await fetch(url2)
}
```

await内部实现了generator，其实await就是generator + Promise的语法糖，且内部实现了自动执行generator

#### 19. 事件机制

事件触发的三个阶段：1. 捕获 2. 传播到事件触发处触发注册事件 3. 冒泡

注册事件的时候如果希望事件值触发在目标上，这时候可以使用stopPropagation（可以阻止冒泡也可以阻止捕获事件）来阻止事件的进一步传播，stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件

#### 20. 跨域

协议，域名，端口有一个不同就是跨域。

为什么要使用同源策略？用来防止CSRF攻击的。

##### 解决跨域

1. JSONP

   利用script标签没有跨域限制的漏洞，通过标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时

   虽然兼容性不错，但是只限于get请求

   封装一个JSONP

   ```javascript
   function jsonp(url, jsonpCallback, success) {
     let script = document.createElement('script')
     script.src = url
     script.async = true
     script.type = 'text/javascript'
     window[jsonpCallback] = function(data) {
       success && success(data)
     }
     document.body.appendChild(script)
   }
   jsonp('http://xxx', 'callback', function(value) {
     console.log(value)
   })
   ```

2. CORS

   需要浏览器和后端同时支持，IE8和9需要XDomainRequest来实现

   浏览器会自动进行CORS通信，实现CORS的关键是后端，服务端设置Access-Control-Allow-Origin就可以开启CORS

3. document.domain

   只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。

   只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

4. postMessage

   主要用于嵌入式页面中的第三方页面数据

   ```javascript
   // 发送消息端
   window.parent.postMessage('message', 'http://test.com')
   // 接收消息端
   var mc = new MessageChannel()
   mc.addEventListener('message', event => {
     var origin = event.origin || event.originalEvent.origin
     if (origin === 'http://test.com') {
       console.log('验证通过')
     }
   })
   ```

#### 21. 存储

|     方式     |                  cookie                  |       localStorage       |  sessionStorage  | indexDB                |
| :----------: | :--------------------------------------: | :----------------------: | :--------------: | ---------------------- |
|   生命周期   |      由服务器生成，可以设置过期时间      | 除非被清理，否则一直存在 | 页面关闭就被清理 | 除非被清理否则一直存在 |
| 数据存储大小 |                    4k                    |            5M            |        5M        | 无限                   |
| 与服务端通信 | 每次都会携带在header中，对于请求影响性能 |          不参与          |      不参与      | 不参与                 |

cookie不建议用于存储，如果没有大量数据存储需求的话，可以使用localStorage和sessionStorage。不怎么改变的数据使用localStorage，否则另一个

cookie需要注意安全性：

|   属性    |                             作用                             |
| :-------: | :----------------------------------------------------------: |
|   value   | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only |              不能通过js访问Cookie，减少xss攻击               |
|  secure   |                只能在协议为HTTPS的请求中携带                 |
| same-site |      规定浏览器不能在跨域请求中携带Cookie，减少CSRF攻击      |



#### 22. service worker

service worker是浏览器背后用来实现缓存的独立线程。使用service worker的话，传输协议必须使用HTTPS。因为service worker中设计请求拦截，所以必须使用HTTPS来保障安全

#### 23. 缓存机制

##### 1. 缓存位置

- Service Worker

  缓存具有持续性

  当没有命中Service Worker缓存时，会根据优先级去查找数据，通过fetch函数去获取数据，不管是总网络请求还是Memory Cache中获取的数据，都会显示从Service Worker中获取的

- Memory Cache

  内存中的缓存，读取速度比磁盘快，虽然搞笑，但是缓存持续性很短，会随着进程的释放而释放，一旦关闭tab，内存中的缓存就被释放了

- Disk Cache

  存储在硬盘中的缓存，读取速度慢点，但是胜在容量和存储时效性

  它会根据HTTP header中的字段来判断那些资源需要缓存，哪些可以不用请求直接使用，哪些过期需要重新请求。

  即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据

- Push Cache

  HTTP/2的内容，并且缓存事件也很短暂，只有在回话中存在，一旦回话结束就被释放

  所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好

  可以推送 `no-cache` 和 `no-store` 的资源

  一旦连接被关闭，Push Cache 就被释放

  多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存

  Push Cache 中的缓存只能被使用一次

  浏览器可以拒绝接受已经存在的资源推送

  你可以给其他域名推送资源

- 网络请求

  为了考虑性能，就需要考虑缓存策略

##### 2. 缓存策略（都是通过HTTP header来实现的）

1. 强缓存（表示在缓存期间不需要请求，state code为200）

   Expires受限于本地时间

   Cache-Control 优先级高于Expires，可以在请求头或者响应头中设置，并且可以组合使用多种指令

   常见指令：

   |     指令     |                           作用                           |
   | :----------: | :------------------------------------------------------: |
   |    public    |           表示响应可以被客户端和代理服务器缓存           |
   |   private    |                 表示响应只能被客户端缓存                 |
   |  max-age=30  |              缓存30秒之后过期，需要重新缓存              |
   | s-max-age=30 |       覆盖max-age，作用一样，只在代理服务器中生效        |
   |   no-store   |                      不缓存任何响应                      |
   |   no-cache   | 资源被缓存，但是立即失效，下次会发起请求验证资源是否过期 |
   | max-stale=30 |             30内，即使缓存过期，也使用该缓存             |
   | min-fresh=30 |                希望在30秒内获取最新的响应                |

   

2. 协商缓存（如果缓存过期，就需要发起请求验证资源是否有更新；Last-Modified和ETag）

   如果浏览器发起请求验证资源时，如果资源没有改变，那么久返回304，并更新有效期

   Last-Modified和If-Modified-Since

   Last-Modified表示本地文件最后修改日期，If-Modified-Since会将Last-Modified的值发给服务器，询问服务器在该日期的资源是否有更新，有更新就会将新的资源发送回来，否则就是304

   但是Last-Modified只能以秒计时，如果在不可感知的时间内修改完文件，那么服务端会认为资源还是命中了，不会返回正确资源

   所以在HTTP1.1出现了ETag

   ETag和If-None-Match

   ETag类似文件指纹，If-None-Match会将当前ETag发送给服务器，询问该资源ETag是否变动，如果有变动就将新资源发送回来，并且ETag优先级高于Last-Modified

##### 3. 实际使用

1. 【频繁变动的资源】使用Cache-Control：nocache使浏览器每次都请求服务器，然后配合ETag或者Last-Modified来验证资源是否有效，虽然不能节省请求数量，但是能显著减少响应数据大小
2. 【代码文件】对文件名进行哈希处理，只有当代码修改后才会生成新的名字，可以给代码文件设置缓存有效期一年Cache-Control: max-age = 31536000

#### 24. 浏览器渲染

插入几万个DOM，如何页面不卡顿？虚拟滚动，原理就是只渲染可视区域的内容，非可见的区域就不渲染，当用户在滚动的时候就去实时替换渲染的内容

什么情况阻塞渲染？渲染的前提是生成渲染树，所以HTML和CSS肯定会阻塞渲染。如果想要渲染的越快，就月应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器；然后当浏览器在解析到script标签是，会暂停构建DOM，完成后再从暂停的地方重新开始。也就是说如果想要首屏渲染越快，就越不应该在首屏加载JS文件，也就是将script标签放在body的底部的原因

也可以给script标签加上defer（表示JS文件会并行下载，但是会放到HTML解析完成后顺序执行）或者async（表示JS文件下载和解析不阻塞渲染）属性

#### 25. 安全

##### 1. XSS

攻击者在目标网站上注入恶意脚本，使之在用户的浏览器上面运行。XSS利用的是用户对指定网站的信任

XSS分为多种类型：持久型（攻击代码被写进数据库）和非持久型（通过修改url参数-Chrome自动就能防御）

XSS注入方法：

```
1. 在HTML内嵌的文本中，通过script标签注入恶意内容

2. 在内联的JavaScript中，破解的数据突破了原本的限制（字符串，变量，方法名等）

3. 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签

4. 在标签的herf、src等属性中，包含JavaScript;等可执行代码

5. 在onload、onerror、onclick等事件中，注入不受控制代码

6. 在style属性和标签中，包含类似background-image:url("javascript;···");的代码（新版浏览器已经可以防范）

7. 在style属性和标签中，包含类似expression(···)的CSS表达式代码（新版浏览器已经可以防范）
```

XSS的预防：

```
1. 输入过滤

2. 纯前端渲染

3. 转义HTML

4. 输入内容长度控制

5. HTTP-only-Cookie：禁止JavaScript读取某些敏感Cookie，攻击者完成之后也无法窃取此Cookie

6. 建立白名单CSP：CSP的开启--1. 设置HTTP Header中的Content-Security-Policy 2. 设置meta标签<meta http-equiv="Content-Security-Policy">
比如只允许加载本站资源：Content-Security-Policy：defalt-src 'self'
只允许加载HTTPS协议图片：Content-Security-Policy:img-src https://*
允许加载任何来源框架：Content-Security-Policy：child-src 'none'
```

##### 2. CSRF

跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站，向被攻击网站发起跨域请求。利用受害者在被攻击网站已获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。CSRF利用网站对用户浏览器的信任。

受害者必须依次完成两个步骤：

1. 登录受信任网站A，并在本地生成Cookie
2. 在不登出A的情况，访问危险的B

CSRF的攻击类型：

```
1. GET类型的CSRF

 ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&for=hacker)
 
在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。

2. POST类型的CSRF

这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：

 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。

3. 链接类型的CSRF

链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：

  <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  重磅消息！！
  <a/>
由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。
```

CSRF的特点：

```
1. 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。

2. 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。

3. 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

4. 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

5. CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。
```

CSRF的防护：

遵循几种规则：

1. Get请求不对数据进行修改
2. 不让第三方网站访问到Cookie
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，比如验证码或者token

1. 同源检测

   HTTP协议中，header有用于标记源域名：Origin Header 和 Referer Header

2. Token验证（因为攻击者冒用的是cookie，所以可以携带一个token作为验证，可以把token存在服务器的session，在客户端把打入所有的a和form标签）

3. Cookie属性Samesite（如果 Samesite=Strict，csrf没有机会，但是跳转子域名或者是新标签打开刚刚登录的网站之前的cookie就不存在；若为lax，安全性就不高；samesite兼容性不好，不支持子域）

#### 26. 防抖，节流

防抖：使用setTimeout辅助实现，主要就是清零；如果方法多次触发，就把上次记录的延迟执行代码清掉，重新开始计时。若计时器件事件没有被重新触发，等延迟时间计时完毕，则执行目标代码。

```javascript
function debounce(func, wait) {
	var timer
	return function() {
		var context = this
		var args = arguments
		clearTimeout(timer)
		timer = setTimeout(function(){
			func.apply(context, args)
		}, wait)
	}
}
```

节流：控制事件的频次

方法一：触发事件的时候，取出当前时间戳，减去之前的时间戳，如果大于，就执行，然后更显现在的时间戳为之前的时间戳，如果小于就不执行

```javascript
function throtte(func, wait) {
	var context, args
	var before = 0
	return function() {
		var now = +new Date() // 隐式转换，相当于ToNumber。将字符串直接转化为number类型
		context = this
		args = arguments
		if (now - before > wait) {
			func.apply(context, args)
			before = now
		}

	}
}
```

方法二：使用定时器

```javascript
function throtte(func, wait) {
	var timer
	var context, args
	return function() {
		context = this
		args = arguments
		if (!timer) {
			timer = setTimeout(function(){
				timer = null
				func.apply(this, args)
			}, wait)
		}
	}
}
```



#### 27. 数组去重

1. indexOf

   ```javascript
   function unique(array) {
       var res = [];
       for (var i = 0, len = array.length; i < len; i++) {
           var current = array[i];
           if (res.indexOf(current) === -1) {
               res.push(current)
           }
       }
       return res;
   }
   ```

2. filter

   ```javascript
   function unique(array) {
       var res = array.filter(function(item, index, array){
           return array.indexOf(item) === index;
       })
       return res;
   }
   ```

3. es6 set

   ```javascript
   function unique(array) {
      return Array.from(new Set(array));
   }
   ```

#### 28. 打平数组

#### 29. 渲染几百万大量日志文件怎么优化

1. 只渲染可视区域，分批次请求
2. 如果一次性拿到大量数据，可以判断滑块和滚动条的比例拿到对应位置的数据；如何解决轻微滚动？类似轮播图的原理，只渲染一条数据
3. 从代码层面，因为日志文件不需要修改，所以可以使用Object.defineProperty来进行属性描述符配置不可修改或者是Object.freeze() (Object.seal()密封)

#### 30. JSONP及其原理

### Vue

#### 1. v-show 和v-if 的区别

切换比较频繁选v-show，否则v-if 

#### 2. Vue生命周期

beforeCreate ——new Vue之后的第一个钩子函数，当前阶段data，watch，method，computed上面的数据和方法都都不能被访问

created——实例创建完成当前阶段已完成数据观测可以使用数据和更改数据不会触发updated函数；当前不能与DOM交互，如果非要访问DOM，就通过$necttick的方式

beforeMount——挂载之前，虚拟DOM完成即将开始渲染，模板导入渲染函数，可以使用数据和更改数据不会触发updated函数

mounted——真实DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点，使用$ref对DOM进行操作

beforeUpdate——响应式数据更新之前，可更改数据，不会造成重渲染

updated——数据更新完毕之后，当前阶段组件DOM已完成更新，避免在此修改数据，会造成无限循环的更新

beforeDestroy——销毁实例之前，可清除定时器，监听，解绑函数等等

destroyed——实例销毁之后，当前只剩下DOM空壳。组件一杯拆除，数据绑定被卸除，监听被移出，子实例也被销毁

#### 3. Vue响应式

**vue2.x核心API——Object.defineProperty**

能监听对象，不能原生监听数组，需要特殊处理

深度监听需要一次性递归到底，一次性计算量大

无法监听新增属性/删除属性（Vue.set  Vue.delete）

```javascript
  function updateView () {
    console.log('更新啦!')
  }

  function defineObserve (target, key, value) {
    /**深度监听
     * 否则value如果是对象将无法被监听
     */
    observer(value)
    Object.defineProperty(target, key, {
      get: function () {
        return value
      },
      set: function (newval) {
        if (newval !== value) {

          /**深度监听（如果不监听设置新值，将会监听不到的情况）
           * 比如 刚开始data.name = 'hahabboom'
           * data.name = {number: 12}
           * data.name.number = 1
           * 最后一次number改变将无法被监听
           */
          observer(newval)

          value = newval
          updateView()
        }
      }
    })
  }

  function observer (target) {
    if (typeof target === null || typeof target !== 'object') {
      return target
    }
    for(let key in target) {
      defineObserve(target, key, target[key])
    }
  }

  let data = {
    name: 'hahabboom',
    age: 11,
    info: {
      detail: 'hi you!!'
    },
    part: ['one', 'two', 'three']
  }
  observer(data)

  // data.name = '231'
  // data.age = 1
  // data.info.detail = 'change'
  data.name = {number: 12}
  data.name.number = 1
```

vue3.x——Proxy

Proxy可深度监听，性能更好（因为他是什么时候get什么时候递归，不像上面那种一次性递归到底）

可监听新增/删除属性

可监听数组变化

Proxy兼容性不好，且无法polyfill

```javascript
function reactive(target = {}) {
    if (typeof target !== 'object' || target == null) {
        // 不是对象或数组，则返回
        return target
    }

    // 代理配置
    const proxyConf = {
        get(target, key, receiver) {
            // 只处理本身（非原型的）属性
            const ownKeys = Reflect.ownKeys(target)
            if (ownKeys.includes(key)) {
                console.log('get', key) // 监听
            }

            const result = Reflect.get(target, key, receiver)

            // 深度监听
            // 性能如何提升的？
            return reactive(result)
        },
        set(target, key, val, receiver) {
            // 重复的数据，不处理
            if (val === target[key]) {
                return true
            }

            const ownKeys = Reflect.ownKeys(target)
            if (ownKeys.includes(key)) {
                console.log('已有的 key', key)
            } else {
                console.log('新增的 key', key)
            }

            const result = Reflect.set(target, key, val, receiver)
            console.log('set', key, val)
            // console.log('result', result) // true
            return result // 是否设置成功
        },
        deleteProperty(target, key) {
            const result = Reflect.deleteProperty(target, key)
            console.log('delete property', key)
            // console.log('result', result) // true
            return result // 是否删除成功
        }
    }

    // 生成代理对象
    const observed = new Proxy(target, proxyConf)
    return observed
}
```



#### 4. Vue如何监听数组变化

```javascript
  function updateView () {
    console.log('更新啦!')
  }

  // 避免污染全局原型
  const oldArray = Array.prototype

  const newArray = Object.create(oldArray);

  ['pop','push'].forEach(name => {
    newArray[name] = function () {
      updateView()
      oldArray[name].call(this, ...arguments)
    }
  })

  function defineObserve (target, key, value) {
    /**深度监听
     * 否则value如果是对象将无法被监听
     */
    observer(value)
    Object.defineProperty(target, key, {
      get: function () {
        return value
      },
      set: function (newval) {
        if (newval !== value) {

          /**深度监听（如果不监听设置新值，将会监听不到的情况）
           * 比如 刚开始data.name = 'hahabboom'
           * data.name = {number: 12}
           * data.name.number = 1
           * 最后一次number改变将无法被监听
           */
          observer(newval)

          value = newval
          updateView()
        }
      }
    })
  }

  function observer (target) {
    if (typeof target === null || typeof target !== 'object') {
      return target
    }
    if (Array.isArray(target)) {
      target.__proto__ = newArray
    }
    for(let key in target) {
      defineObserve(target, key, target[key])
    }
  }
```



#### 5. Vue双向绑定

##### 方案一：

子组件$emit派发input事件，父组件监听input事件中的value值，并存起来；父组件通过prop的形式传递给子组件value值，子组件将其绑定在value上

父组件

```vue
<message-demo :text="name" @change="name = $event"></message-demo>
```

子组件

```vue
 <input type="text" :value="text" @input="$emit('change', $event.target.value)">
```

##### 方案二：

使用model指令，指定prop和event

父组件

```vue
<message-demo v-model="name"></message-demo>
```

子组件

```vue
<input type="text" :value="text">
<script>
export default {
  name: 'messageDemo',
  model: {
    prop: 'text',
    event: 'change'
  },
  data () {
    return {
    }
  }
  }
</script>
```

#### 6. 虚拟DOM

JS如何模拟DOM结构

![image-20210324143014697](C:\Users\Damo\AppData\Roaming\Typora\typora-user-images\image-20210324143014697.png)

```javascript
{
    tag: 'div',
    props: {
        className: 'container',
        id: 'div1'
    },
    children: [
        {
            tag: 'p',
            children: 'vdom'
        },
        ...
    ]
}
```

DOM可以通过JS对象来模拟，反之也可以通过JS对象来渲染出对于的DOM，难点就在于如何判断新旧两个JS对象的最小差异并且实现拒不更新DOM

 Virtual DOM 提高性能是其中一个优势，其实**最大的优势**还是在于：

1. 将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。
2. 同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。
3. 实现组件的高度抽象化

#### 7. diff算法

优化时间复杂度到On

只比较同一层级，不跨级比较

tag不同，直接删除重建，不在深度比较

tag和key，两者都想吐，则认为是相同节点，不再深度比较

#### 8. 模板编译

js的with语法



#### 9. v-for中为什么使用key

必须使用key，并且不能是index和random；

diff算法通过tag和key来判断，是否是sameNode

减少渲染次数，提升渲染性能

#### 10. 何时使用异步组件

加载大组件；路由组件加载

#### 11. 何时需要使用beforeDestroy

解绑自定义事件event.$off

清除定时器

解绑自定义的DOM事件，如winodw scroll等

#### 12. vuex中action和mutation有何区别

action中处理异步，mutation不可以

mutation做原子操作

action可以整合多个mutation

#### 13. vue为何是异步渲染，$nextTick何用

异步渲染（以及合并data修改），以提高渲染性能

$nextTick在DOM更新完成之后，触发回调



#### 14. 路由原理

本质就是监听URL变化，然后匹配路由规则，显示相应的页面

##### Hash模式

`www.test.com/#/`当 `#` 后面的哈希值发生变化时，可以通过 `hashchange` 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 `www.test.com`。

##### History模式

H5新功能，主要使用 `history.pushState` 和 `history.replaceState` 改变 URL



- Hash 模式只可以更改 `#` 后面的内容，History 模式可以通过 API 设置任意的同源 URL
- History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
- Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 `index.html` 页面用于匹配不到静态资源的时候

#### 15. 组件通信

##### 父子通信

props，emit —— 单向数据流，子组件必须通过发送事件的方式告知父组件修改数据





#### 16. keep-alive

防止组件状态多次渲染，可以使用keep-alive包裹

对于 `keep-alive` 组件来说，它拥有两个独有的生命周期钩子函数，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `actived` 钩子函数。

`include`定义缓存白名单，keep-alive会缓存命中的组件；

`exclude`定义缓存黑名单，被命中的组件将不会被缓存；

`max`定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。

原理：

`<keep-alive>` 组件是一个抽象组件，它的实现通过自定义 `render` 函数并且利用了插槽，我们也是在keep-alive标签内部写东西，所以先获取默认插槽，再获取它的第一个子节点，keep-alive只处理第一个子元素，所以一般和它搭配使用的component动态组件或者是router-view

然后判断当前组件的名称和include和exclude的关系，如果满足了配置 `include` 且不匹配或者是配置了 `exclude` 且匹配，那么就直接返回这个组件的 `vnode`，否则的话走下一步缓存；如果命中缓存，则直接从缓存中拿vnode的实力，并且调整了key的顺序放在最后一个；否则把vnode设置缓存，最后还有一个逻辑，如果配置了 `max` 并且缓存的长度超过了 `this.max`，还要从缓存中删除第一个。

除了从缓存中删除外，还要判断如果要删除的缓存并的组件 `tag` 不是当前渲染组件 `tag`，也执行删除缓存的组件实例的 `$destroy` 方法。逻辑很简单，观测他们的变化执行 `pruneCache` 函数，其实就是对 `cache` 做遍历，发现缓存的节点名称和新的规则没有匹配上的时候，就把这个缓存节点从缓存中摘除。

 Vue 的渲染最后都会到 `patch` 过程，而组件的 `patch` 过程会执行 `createComponent` 方法，第一次渲染的时候，`vnode.componentInstance` 为 `undefined`，`vnode.data.keepAlive` 为 true，因为它的父组件 `<keep-alive>` 的 `render` 函数会先执行，那么该 `vnode` 缓存到内存中，并且设置 `vnode.data.keepAlive` 为 true，因此 `isReactivated` 为 `false`，那么走正常的 `init` 的钩子函数执行组件的 `mount`。当 `vnode` 已经执行完 `patch` 后，执行 `initComponent` 函数，`vnode.elm` 缓存了 `vnode` 创建生成的 DOM 节点。

 `B` 组件再次点击 `switch` 切换到 `A` 组件，就会命中缓存渲染。`patchVnode` 在做各种 diff 之前，会先执行 `prepatch` 的钩子函数，`prepatch` 核心逻辑就是执行 `updateChildComponent` 方法，执行 `prepatch` 的时候，需要对自己的 `children`，也就是这些 `slots` 做重新解析，并触发 `<keep-alive>` 组件实例 `$forceUpdate` 逻辑，也就是重新执行 `<keep-alive>` 的 `render` 方法，这个时候如果它包裹的第一个组件 `vnode` 命中缓存，则直接返回缓存中的 `vnode.componentInstance`，这个时候 `isReactivated` 为 true，并且在执行 `init` 钩子函数的时候不会再执行组件的 `mount` 过程了，这也就是被 `<keep-alive>` 包裹的组件在有缓存的时候就不会在执行组件的 `created`、`mounted` 等钩子函数的原因了。回到 `createComponent` 方法，在 `isReactivated` 为 true 的情况下会执行 `reactivateComponent` 方法



#### 17. extend能做什么

作用是扩展组件生成一个构造器，与$mount一起使用

### webpack模块

#### 1. 前端模块化

##### 什么是模块？

- 将一个复杂的程序依据一定的规则（规范）封装成几个块（文件）并进行组合在一起

- 块的内部数据与实现是私有的，只是向外部暴露一些接口（方法）与外部其他模块通信

##### 模块化的好处

- 避免命名冲突
- 更好的分离，按需加载
- 更好复用性
- 高可维护性

##### 引入多个script后出现的问题

- 请求过多
- 依赖模糊--不知道具体的依赖关系是什么，很容易因为不了解他们之间的依赖关系导致加载先后顺序出错
- 难以维护--以上两个问题就导致难以维护，很有可能牵一发动全身

##### 模块化规范

- CommonJS（node，每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量函数类都是私有的，对其他文件不可见；在服务端，模块加载是运行时同步加载的；在浏览器端，模块是需要提前编译打包处理）

  特点：

  1. 所有代码都运行在模块作用域，不会污染全局作用域

  2. 所有模块都可多参加在，但是只会在第一次加载是运行一次，然后运行结果就被缓存了，以后直接读取缓存
  3. 模块加载顺序是按照在代码中出现的顺序

  基本语法：

  ```javascript
  1. 暴露模块
  var x = 5;
  var addX = function (value) {
    return value + x;
  };
  module.exports.x = x;
  module.exports.addX = addX;
  2. 引入模块
  var example = require('./example.js');//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径
  ```

  模块加载机制：

  输入的是被输出的值的拷贝，因为比如输出一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值

- AMD（非同步加载模块，允许指定回调函数，AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。）

  语法：

  ```javascript
  //定义有依赖的模块
  define(['module1', 'module2'], function(m1, m2){
     return 模块
  })
  引入使用模块:
  
  require(['module1', 'module2'], function(m1, m2){
     使用m1/m2
  })
  ```

  AMD不会污染全局环境，能够清楚地显示依赖关系，AMD可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块

- CMD（专门用于浏览器端，模块加载异步，模块使用时才会加载执行。CMD整合了CommonJS和AMD规范的特点）

  语法：

  ```javascript
  // 定义没有依赖模块
  define(function(require, exports, module){
    exports.xxx = value
    module.exports = value
  })
  // 引用使用模块
  define(function (require) {
    var m1 = require('./module1')
    var m4 = require('./module4')
    m1.show()
    m4.show()
  })
  ```
- ES6模块化（设计思想还是尽量静态化，使得编译的时候就能确定模块依赖关系）

  ```javascript
    // export-default.js
    export default function () {
      console.log('foo');
    }
    // import-default.js
    import customName from './export-default';
    customName(); // 'foo
  ```

  - CommonJS 支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
  - CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
  - CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
  - ES Module 会编译成 `require/exports` 来执行的



#### 2. tree-shaking

webpack 2增加了tree-shaking的功能

Tree-shaking的本质是消除无用的js代码

为了学会使用 *tree shaking*，你必须……

- 使用 ES2015 模块语法（即 `import` 和 `export`）。
- 在项目 `package.json` 文件中，添加一个 "sideEffects" 入口。
- 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 `UglifyJSPlugin`）。

#### 3. 基本配置

设置代理

```javascript
proxy: {
	'/api': 'http://local:3000',
	'/api2': {
		target: 'http://local:3000',
		pathRewrite: {
			'/api2': ''
		}
	}
}
```

loader执行顺序从后往前

```
{
	loader: ['style-loader', 'css-loader', 'postcss-loader' // 负责添加浏览器前缀之类，兼容性更好]（生产环境写法）
}
```

#### 4. 多入口配置

- 在webpack中配置

  1. common.js中配置entry和plugins

  ```
      entry: {
          index: path.join(srcPath, 'index.js'),
          other: path.join(srcPath, 'other.js')
      },
      
      plugins: [
          // 多入口 - 生成 index.html
          new HtmlWebpackPlugin({
              template: path.join(srcPath, 'index.html'),
              filename: 'index.html',
              // chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用
              chunks: ['index']  // 只引用 index.js
          }),
          // 多入口 - 生成 other.html
          new HtmlWebpackPlugin({
              template: path.join(srcPath, 'other.html'),
              filename: 'other.html',
              chunks: ['other']  // 只引用 other.js
          })
      ]
  ```

  2. 在prod里面配置output

  ```
      output: {
          // filename: 'bundle.[contentHash:8].js',  // 打包代码时，加上 hash 戳
          filename: '[name].[contentHash:8].js', // name 即多入口时 entry 的 key
          path: distPath,
      },
  ```

- vue-cli 3中配置

  配置pages

  ```
  pages: {
    business: {
      // page 的入口
      entry: 'src/views/business/main.js',
      // 模板来源
      template: 'public/index.html',
      // 在 dist/index.html 的输出
      filename: 'index.html',
      // 当使用 title 选项时，
      // template 中的 title 标签需要是 <title><%= htmlWebpackPlugin.options.title %></title>
      title: '综合气象观测业务运行信息化平台',
      chunks: ['chunk-vendors', 'chunk-common', 'business']
    },
    ksh: {
      // page 的入口
      entry: 'src/views/ksh/main.js',
      // 模板来源
      template: 'public/ksh.html',
      // 在 dist/index.html 的输出
      filename: 'ksh.html',
      // 当使用 title 选项时，
      // template 中的 title 标签需要是 <title><%= htmlWebpackPlugin.options.title %></title>
      title: '全国天气雷达在线分析系统',
      chunks: ['chunk-vendors', 'chunk-common', 'ksh']
    }
  }
  ```

  

#### 5.  webpack如何抽离压缩css文件

1. 在prod.js里面安装引入mini-css-extract-plugin插件

2. 在rules里写上

   ```
               {
                   test: /\.css$/,
                   loader: [
                       MiniCssExtractPlugin.loader,  // 注意，这里不再用 style-loader
                       'css-loader',
                       'postcss-loader'
                   ]
               },
               // 抽离 less --> css
               {
                   test: /\.less$/,
                   loader: [
                       MiniCssExtractPlugin.loader,  // 注意，这里不再用 style-loader
                       'css-loader',
                       'less-loader',
                       'postcss-loader'
                   ]
               }
   ```

   

3. 在plugins里增加配置（生产环境使用hash，增加被命中缓存的概率，速度会快一些）

   ```
           new MiniCssExtractPlugin({
               filename: 'css/main.[contentHash:8].css'
           })
   ```

   接着就是压缩，安装插件 terser-webpack-plugin 和 optimize-css-assets-webpack-plugin ：

   ```
       optimization: {
           // 压缩 css
           minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})],
       }
     
   ```

#### 6. webpack如何抽离公共代码和第三方代码

在optimization里面进行配置：

```javascript
        // 分割代码块
        splitChunks: {
            chunks: 'all',
            /**
             * initial 入口 chunk，对于异步导入的文件不处理
                async 异步 chunk，只对异步导入的文件处理
                all 全部 chunk
             */

            // 缓存分组
            cacheGroups: {
                // 第三方模块
                vendor: {
                    name: 'vendor', // chunk 名称
                    priority: 1, // 权限更高，优先抽离，重要！！！,比如我有个代码又是第三方又是公共模块，优先命中第三方里面
                    test: /node_modules/, // 命中范围
                    minSize: 0,  // 大小限制
                    minChunks: 1  // 最少复用过几次
                },

                // 公共的模块
                common: {
                    name: 'common', // chunk 名称
                    priority: 0, // 优先级
                    minSize: 0,  // 公共模块的大小限制
                    minChunks: 2  // 公共模块最少复用过几次
                }
            }
        }
```

所以在进行多入口配置的时候会有chunks的配置，就是因为考虑代码分割的问题了

#### 7. webpack如何实现异步加载

```
setTimeOut(() => {
// 类似定义一个chunk
	import('./xxx.js').then(res => {
		console.log(res)
	})
}, 1500)
```

webpack实现懒加载就是import + vue/react异步组件 + vue-router/react-router异步加载路由

#### 8. module chunk bundle区别

module——各个源码文件，webpack中一切皆模块

chunk——多模块合并成的（webpack分析过程中），如entry import() splitChunks

bundle——最终输出文件（一个chunk对应一个bundle）

#### 9. webpack性能优化

- 优化打包构建速度——开发体验和效率

  1. 优化babel-loader 

     - 开启缓存 
     - 明确范围（include和exclude二者选一个就可以）

     ```
     {
     	test: /\.js$/,
     	use: ['babel-loader?cacheDirecyory'], //开启缓存
     	include： path.resolve(_dirname, 'src') // 明确范围
     }
     ```

  2. IgnorePlugin（webpack内置插件，忽略第三方指定目录，让这些指定目录不要被打包进去）

     ```
     plugins:[
     	new Webpack.IgnorePlugin(/\.\/locale/,/moment/),//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去
     ]
     // 因为上面忽略了那个目录，需要手动引入中文语言目录
     ```

  3. noParse（避免去打包那些东西）

  4. happyPack（多进程打包，生产和开发环境都可以）

     因为js是单线程，开启多进程打包

     项目较大，打包较慢，开启多进程能提高速度

     项目较小，打包较快，开启多进程会降低速度（进程开销）

     ```
     引入happypack
     然后在rules改写js的
         {
             test: /\.js$/,
             // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例
             use: ['happypack/loader?id=babel'],
             include: srcPath,
             // exclude: /node_modules/
         }
     然后在plugins里面 new HappyPack
             new HappyPack({
                 // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件
                 id: 'babel',
                 // 如何处理 .js 文件，用法和 Loader 配置中一样
                 loaders: ['babel-loader?cacheDirectory']
             }),
     ```

  5. ParallelUglifyPlugin（多进程压缩JS，只能生产环境）

     webpack内置Uglify工具压缩JS

     JS单线程，开启多进程压缩更快

     和happyPack同理

     ```
             // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码
             new ParallelUglifyPlugin({
                 // 传递给 UglifyJS 的参数
                 // （还是使用 UglifyJS 压缩，只不过帮助开启了多进程）
                 uglifyJS: {
                     output: {
                         beautify: false, // 最紧凑的输出
                         comments: false, // 删除所有的注释
                     },
                     compress: {
                         // 删除所有的 `console` 语句，可以兼容ie浏览器
                         drop_console: true,
                         // 内嵌定义了但是只用到一次的变量
                         collapse_vars: true,
                         // 提取出出现多次但是没有定义成变量去引用的静态值
                         reduce_vars: true,
                     }
                 }
             })
     ```

     

  6. 自动刷新（不能用于生产环境）

     watch:true  开启监听

     // 但是在开发环境下开了devServer就会自动开启刷新浏览器，其实就会覆盖watch

     ```
          watch: true, // 开启监听，默认为 false
          watchOptions: {
              ignored: /node_modules/, // 忽略哪些
              // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高
              // 默认为 300ms
              aggregateTimeout: 300,
              // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的
              // 默认每隔1000毫秒询问一次
              poll: 1000
         }
     ```

  7. 热更新（不能用于生产环境）

     因为自动刷新的话，整个网页全部刷新，速度较慢，状态会丢失

     热更新：新代码生效，网页不刷新，状态不丢失（比如全局变量还在，输入框的内容还在，路由不丢失）

     优化会付出代价

     首先引入插件 HotModuleReplacementPlugin

     然后将entry的index改写成数组：

     ```
         entry: {
             // index: path.join(srcPath, 'index.js'),
             index: [
                 'webpack-dev-server/client?http://localhost:8080/',
                 'webpack/hot/dev-server',
                 path.join(srcPath, 'index.js')
             ],
             other: path.join(srcPath, 'other.js')
         },
     ```

     然后在plugins里面new HotModuleReplacementPlugin

     ```
         plugins: [
             new HotModuleReplacementPlugin()
         ],
     ```

     最后在devServer里面 开启hot：true

     如果在监听范围之外需要手动允许那些模块进行热更新（所以需要成本的）

     ```
      if (module.hot) {
          module.hot.accept(['./math'], () => {
              const sumRes = sum(10, 30)
              console.log('sumRes in hot', sumRes)
          })
      }
     ```

  4. DllPlugin（动态链接库插件，只开发环境）

     前端框架Vue体积大，构建慢，但是较稳定，不会经常升级版本；同一个版本只会构建一次，不用每次都重新构建
     
     webpack已内置DllPlugin支持
     
     DllPlugin——将vue打包出dll文件
     
     DllReferencePlugin——使用dll文件
     
     步骤1：新建一个webpack.dll.js文件，在里面引入DllPlugin，在module.exports里面配置entry，output，plugin
     
     ```javascript
     const path = require('path')
     const DllPlugin = require('webpack/lib/DllPlugin')
     const { srcPath, distPath } = require('./paths')
     
     module.exports = {
       mode: 'development',
       // JS 执行入口文件
       entry: {
         // 把 React 相关模块的放到一个单独的动态链接库
         react: ['react', 'react-dom']
       },
       output: {
         // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，
         // 也就是 entry 中配置的 react 和 polyfill
         filename: '[name].dll.js',
         // 输出的文件都放到 dist 目录下
         path: distPath,
         // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react
         // 之所以在前面加上 _dll_ 是为了防止全局变量冲突
         library: '_dll_[name]',
       },
       plugins: [
         // 接入 DllPlugin
         new DllPlugin({
           // 动态链接库的全局变量名称，需要和 output.library 中保持一致
           // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值
           // 例如 react.manifest.json 中就有 "name": "_dll_react"
           name: '_dll_[name]',
           // 描述动态链接库的 manifest.json 文件输出时的文件名称
           path: path.join(distPath, '[name].manifest.json'),
         }),
       ],
     }
     ```
     
     步骤二：在package.json里面的scripts里面再加一条dll指令，就可以执行了
     
     ```javascript
      "scripts": {
         "test": "echo \"Error: no test specified\" && exit 1",
         "dev": "webpack-dev-server --config build/webpack.dev.js",
         "dll": "webpack --config build/webpack.dll.js"
       },
     ```
     
     步骤三：然后就可以在index.html里面引用了，但是需要DllReferencePlugin插件配置：1.在dev.js里面引入该插件，2. 在rules忽略node_modules ,3. 在 plugins 里面new一下，高数webpack使用了哪些动态链接库
     
     ```javascript
     // 第一，引入 DllReferencePlugin
     const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');
     
     // 第二，不要再转换 node_modules 的代码
         module: {
             rules: [
                 {
                     test: /\.js$/,
                     loader: ['babel-loader'],
                     include: srcPath,
                     exclude: /node_modules/ // 第二，不要再转换 node_modules 的代码
                 },
             ]
         },
     
             
           plugins: [
             new webpack.DefinePlugin({
                 // window.ENV = 'production'
                 ENV: JSON.stringify('development')
             }),
             // 第三，告诉 Webpack 使用了哪些动态链接库
             new DllReferencePlugin({
                 // 描述 react 动态链接库的文件内容
                 manifest: require(path.join(distPath, 'react.manifest.json')),
             }),
         ],
             
     ```
     
     

- 优化产出代码——产品性能

  体积更小；合理分包，不重复加载；速度更快，内存使用更少

  1. 小图片base64编码

  2. bundle加hash（根据文件内容算hash值，如果文件没有改变hash值不会改变，就更容易命中缓存）

  3. 懒加载

  4. 提取公共代码

  5. IngorePlugin（忽略多语言，只引用自己需要的语言）

  6. 使用CDN加速

     步骤： 1.  在prod.js的output设置一个公共publicPath，修改所有静态文件的url前缀

     ```javascript
         output: {
             filename: 'bundle.[contentHash:8].js',  // 打包代码时，加上 hash 戳
             path: distPath,
             // publicPath: 'http://cdn.abc.com'  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到
         },
     ```

     			2. 把打包出来的js，css，图片上传到cdn上面

  7. 使用production

     自动开启压缩代码——webpack4.x后才有

     vue react会自动删掉调试代码（如开发环境的warning）

     启动Tree-Shaking（webpack4 自己就有了 ，必须使用ES6 Module才能使tree-shaking生效）

     ​	为什么？

     ​	ES6Module静态引入，编译时引入；Commonjs动态引入，执行时引入；只有静态分析才能实现Tree-Shaking

     ![image-20210326164021355](C:\Users\Damo\AppData\Roaming\Typora\typora-user-images\image-20210326164021355.png)

  

  1. Scope Hosting（代码体积越大效果越好）

     代码体积更小；创建作用域更少；代码可读性更好

     ![image-20210326164614264](C:\Users\Damo\AppData\Roaming\Typora\typora-user-images\image-20210326164614264.png)



#### 10. babel（将各种语言转换为浏览器可以认识的语言 ，ECMAScript 2015+ 代码转换为当前和旧版浏览器或环境中的向后兼容版本的 JavaScript）

webpack 通过 babel-loader 使用 Babel 





#### 11. babel-polyfill

所有的函数的polyfill的集合——core.js

支持generator语法——regenerator

babel-polyfill就是以上的集合

babel-polyfill如何按需引入？—— 

在babellrc文件里面的presets增加配置"useBuiltIns": "usage"

```javascript
{
    "presets": [
        [
            "@babel/preset-env",
            {
                "useBuiltIns": "usage",
                "corejs": 3
            }
        ]
    ]
}
```

babel-pollyfill存在的问题？

会污染全局（因为重新定义了函数，如果做一个独立的web系统就没有问题；如果做第三方库，就存在问题），使用babel-runtime，首先安装插件

```javascript
  "devDependencies": {
    "@babel/cli": "^7.7.5",
    "@babel/core": "^7.7.5",
    "@babel/plugin-transform-runtime": "^7.7.5",
    "@babel/preset-env": "^7.7.5"
  },
  "dependencies": {
    "@babel/polyfill": "^7.7.0",
    "@babel/runtime": "^7.7.5"
  }
```

然后修改babelrc的配置

```javascript
    "plugins": [
        [
            "@babel/plugin-transform-runtime",
            {
                "absoluteRuntime": false,
                "corejs": 3,
                "helpers": true,
                "regenerator": true,
                "useESModules": false
            }
        ]
    ]
```

####  12. 前端为什么要进行打包和构建

1. 体积更小（tree-shaking，压缩，合并），加载更快
2. 编译更加高级语言或语法（TS，ES6+，模块化，scss）
3. 兼容性和错误检查（polyfill，postcss，eslint）
4. 统一，高效的开发环境
5. 统一的构建流程和产出标准
6. 集成公司构建规范（提测，上线等）

#### 13. loader和plugin的区别

loader——模块转换器

plugin——扩展插件，如HtmlWebpackPlugin（吧js，css塞进一个html文件里面）

常见的loader和plugin

#### 14. babel和webpack的区别

babel——js新语法编译工具，不关心模块化

webpack——打包构建工具，不关心语法，是多个loader，plugin的集合

#### 15. 为什么proxy不能被polyfill

因为proxy不能用Object.defineProperty模拟

### websoket

#### 介绍

1. 服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种
2. 建立在TCP协议之上，服务端的实现比较容易
3. 与HTTP协议有着良好的兼容性，默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手不容易被屏蔽，能通过各种HTTP代理服务器
4. 数据格式比较轻量，性能开销小，通信高效
5. 可以发送文本，也可以发送二进制数据
6. 没有同源限制，客户端可以与任意服务器通信
7. 协议标识符是ws（如果加密是wss），服务器网址就是URL

#### 简单用法

```javascript
var ws = new WebSocket('')

// 用于指定连接成功后的回调函数
ws.onopen = function () {
    console.log('连接成功')
}
// 用于指定收到服务器数据后的回调函数
ws.onmessage = function(evt) {
  console.log( "Received Message: " + evt.data);
  ws.close();
  ws.send('your message');  // 向服务器发送数据
};
// 用于指定连接关闭后的回调函数
ws.onclose = function(evt) {
  console.log("Connection closed.");
};    

// 用于指定报错时的回调函数
ws.onerror = function(event) {
  // handle error event
};
```





### 网络

#### 1. TCP

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

PS：第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同的 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。



为什么TCP两次就可以建立连接，却需要3次？

防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误



**第一次握手**

若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

**第二次握手**

B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

**第三次握手**

B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。

**第四次握手**

A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。



**为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？**

为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。

#### 2. POST和GET区别

- Get 请求能缓存，Post 不能
- Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 `body` 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
- URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制

#### 3. 常见状态码

**2XX 成功**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

**3XX 重定向**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**4XX 客户端错误**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**5XX 服务器错误**

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

#### 4. HTTP版本

HTTP1.1——1. 增加keep-alive 2. 管线化 3. 增加了cache-control

HTTP2 —— 1. 二进制协议 2.可以在一个TCP连接中并发请求多个HTTP请求 3. 压缩头部 4. 允许服务端在客户端放cache

 